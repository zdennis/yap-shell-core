### Shell

The shell takes input from the user, turns them into commands, and then runs them by evaluating or executing them. It is responsible for job control, and for providing useful information to the user such as a prompt and other line decorations.

The shell collects input from the user by running a REPL. It then takes the input collected and turns in into a parse tree. The parse tree is then walked, evaluating nodes along the way, which is what evaluates/executes the command. Before each command is evaluated it is processed in order to expand aliases, environment variables, etc.

The parse tree is generated by the yap/shell/line-parser. All nodes are defined by that library.

### Nodes

The nodes that the parse tree knows about are the following: AssignmentNode, ConditionalNode, CommandNode, EnvNode, EnvWrapperNode, InternalEvalNode, PipelineNode, RedirectionNode, and StatementsNode.

These are evaluated by the Shell in the following manner.

#### AssignmentNode, EnvNode, EnvWrapperNode

An env node represents a type of assignment such as an expression "A=B". This node is evaluated to set environment variables for the current execution context.

Currently an AssignmentNode is not used, but it may be used to replace an EnvNode as necessary. An EnvWrapperNode is a meta-EnvNode, all it does is wrap EnvNode(s). It is on the chopping block to go away with parser optimizations that would merge all of these types of concepts together.

#### ConditionalNode

A conditional node represents a conditional expression such as "&&" or "||". It is evaluated by processing its left child node and then processing its right child node based on its result.

#### CommandNode

A command node represents any command and arguments provided by the user such as the "ls" in "ls -al" or the "echo" in "echo foo bar baz".

The command associated with a command node may be a shell function, an alias, a builtin, or an executable found on the file-system. This lookup and determination of what the command refers to is determined when processing a command node.

Every command executed generates an exit status or a signal status.

#### InternalEvalNode

An internal eval node represents an expression that should be evaluated internally (currently only supports the ruby interpreter running the shell).

It needs to generate an exit status or a signal status.

#### PipelineNode

A pipeline node represents a series of commands or statements where the output of one should be the input of another. For example, "ls | grep foo" is a pipeline.

#### RedirectionNode

A redirection node represents the intent to redirect STDOUT, STDERR, or both to file. For example, "echo foo > bar.txt".

#### StatementsNode

A statements node represents more than one statement and contains two nodes: a head and a tail. Either node can refer to any other node.


### Commands

In order to process a CommandNode it must first determine what type of command it represents. Since a CommandNode could refer to a shell function, alias, builtin, or executable on the file-system, we need to determine which one.

The CommandFactory is used to do just this.


### Execution

Once a CommandNode is fully expanded, the resulting command will be executed in a corresponding ExecutionContext. There is an execution context for every type command that can be run.

It is the job of the execution context to handle wiring up stdin, stdout, stderr before running a command as well as provide the exit status or signal status after a command has finished executing.


#### Handling SIGINT

The shell responds to a SIGINT signal (typically Ctrl-C) which will interrupt execution of the shell or any running process.

When a process is not running and a SIGINT is received the REPL will print a "^C" and then put a new line and prompt. The shell will not abort itself.

When a process is running and the SIGINT signal is received it will forwarded on to the currently running child process. In most cases, the child process will abort, but in some cases it will not. An example of this is program like `irb` that is itself an interactive REPL with the user.

#### Handling SIGSTOP / SIGCONT

The shell responds to a SIGSTOP signal (typically Ctrl-Z) by forwarding it to the currently running process.

When no process is running it prints "^Z" in the REPL and prints a new line and prompt. The shell itself will not suspend.

When a process is running and the SIGSTOP signal is received it will be forwarded on to the currently running child process. In most cases, the child process will suspend running.

When the child process is suspended control will be returned to the REPL, a user will be able to run new commands. The suspended process can be restarted by sending it the SIGCONT signal. The `fg` builtin can be used to send the suspended process the SIGCONT signal.


### Job Control

.
