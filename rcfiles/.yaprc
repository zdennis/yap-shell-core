#!/usr/bin/ruby

ENV["PATH"] = "/Applications/Postgres.app/Contents/MacOS/bin:/usr/local/share/npm/bin/:/usr/local/heroku/bin:/Users/zdennis/.bin:/Users/zdennis/.rvm/gems/ruby-2.1.5/bin:/Users/zdennis/.rvm/gems/ruby-2.1.5@global/bin:/Users/zdennis/.rvm/rubies/ruby-2.1.5/bin:/usr/local/bin:/usr/local/sbin:/Users/zdennis/bin:/bin:/opt/local/bin:/opt/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/X11/bin:/usr/local/CrossPack-AVR/bin:/private/tmp/.tidbits/bin:/Users/zdennis/source/playground/AdobeAir/AdobeAIRSDK/bin:/Users/zdennis/.rvm/bin:/Users/zdennis/Downloads/adt-bundle-mac-x86_64-20130219/sdk/tools/:/Users/zdennis/.rvm/bin"
ENV["GEM_HOME"] = "/Users/zdennis/.rvm/gems/ruby-2.1.5:/Users/zdennis/.rvm/gems/ruby-2.1.5@global"

# require 'chronic'
# require 'term/ansicolor'
require 'terminfo'

#
# Configuring your prompt. This can be set to a static value or to a
# Proc like object that responds to #call. If it responds to call it will
# be used every time the prompt is to be re-drawn
#

last_prompt = nil
self.prompt = -> do
  pwd = Dir.pwd.sub Regexp.new(ENV['HOME']), '~'

  git_current_branch = `git branch | sed -n '/\* /s///p' 2>/dev/null`.chomp
  if git_current_branch.length > 0
    git_current_branch += " "
    git_dirty_not_cached = `git diff --shortstat`.length > 0
    git_dirty_cached = `git diff --shortstat --cached`.length > 0

    if git_dirty_not_cached || git_dirty_cached
      git_branch = intense_cyan(git_current_branch)
    else
      git_branch = cyan(git_current_branch)
    end
  else
    git_branch = ""
  end

  arrow = '➜'

  # ~/source/playground/yap master ➜
  last_prompt = "#{dark(green('£'))} #{yellow(pwd)} #{git_branch}#{red(arrow)} "
end

# world = self
# thr = Thread.new do
#   loop do
#     sleep 1
#
#     # Make sure we're in the foreground otherwise trying Error::EIO will be
#     # thrown trying to talk to STDOUT.
#     if world.foreground?
#       t = TermInfo.new(ENV["TERM"], STDOUT)
#
#       current_prompt_text = self.prompt.text
#       new_prompt_text = self.prompt.update.text
#
#       if current_prompt_text != new_prompt_text
#         buffer = Readline.line_buffer
#
#         # clear to beginning of the line
#         t.control "el1", 1
#
#         # move cursor to the first column of the current row
#         t.control "cr", 1
#         print new_prompt_text, buffer
#         Readline.redisplay
#       end
#     end
#   end
# end
# thr.abort_on_exception = true
#

func :upcase do |args:, stdin:, stdout:, stderr:|
  str = stdin.read
  stdout.puts str.upcase
end
