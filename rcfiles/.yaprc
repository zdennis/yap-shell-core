#!/usr/bin/ruby

# ENV["PATH"] = "/Applications/Postgres.app/Contents/MacOS/bin:/usr/local/share/npm/bin/:/usr/local/heroku/bin:/Users/zdennis/.bin:/Users/zdennis/.rvm/gems/ruby-2.1.5/bin:/Users/zdennis/.rvm/gems/ruby-2.1.5@global/bin:/Users/zdennis/.rvm/rubies/ruby-2.1.5/bin:/usr/local/bin:/usr/local/sbin:/Users/zdennis/bin:/bin:/opt/local/bin:/opt/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/X11/bin:/usr/local/CrossPack-AVR/bin:/private/tmp/.tidbits/bin:/Users/zdennis/source/playground/AdobeAir/AdobeAIRSDK/bin:/Users/zdennis/.rvm/bin:/Users/zdennis/Downloads/adt-bundle-mac-x86_64-20130219/sdk/tools/:/Users/zdennis/.rvm/bin"
# ENV["GEM_HOME"] = "/Users/zdennis/.rvm/gems/ruby-2.1.5:/Users/zdennis/.rvm/gems/ruby-2.1.5@global"

require 'chronic'
require 'term/ansicolor'
require 'terminfo'

#
# Configuring your prompt. This can be set to a static value or to a
# Proc like object that responds to #call. If it responds to call it will
# be used every time the prompt is to be re-drawn
#

self[:tab_completion].instance_eval do
  add_completion(match:"ls") do
    [
      OpenStruct.new(type: :hrm, text: "foo"),
      OpenStruct.new(type: :hrm, text: "bar"),
      OpenStruct.new(type: :file, text: "baz")
    ]
  end

  set_decoration :hrm do |txt|
    Term::ANSIColor.yellow(txt)
  end
end

last_prompt = nil
self.prompt = -> do
  pwd = Dir.pwd.sub Regexp.new(ENV['HOME']), '~'

  git_current_branch = `git branch 2>/dev/null | sed -n '/\* /s///p'`.chomp
  if git_current_branch.length > 0
    git_current_branch += " "
    git_dirty_not_cached = `git diff --shortstat 2>/dev/null`.length > 0
    git_dirty_cached = `git diff --shortstat --cached 2>/dev/null`.length > 0

    if git_dirty_not_cached || git_dirty_cached
      git_branch = intense_cyan(git_current_branch)
    else
      git_branch = cyan(git_current_branch)
    end
  else
    git_branch = ""
  end

  arrow = '➜'

  # ~/source/playground/yap master ➜
  last_prompt = "#{dark(green('£'))} #{yellow(pwd)} #{git_branch}#{red(arrow)} "
end

func :upcase do |args:, stdin:, stdout:, stderr:|
  str = stdin.read
  stdout.puts str.upcase
end
