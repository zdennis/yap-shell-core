#!/usr/bin/ruby

require 'chronic'
require 'term/ansicolor'

#
# Configuring your prompt. This can be set to a static value or to a
# Proc like object that responds to #call. If it responds to call it will
# be used every time the prompt is to be re-drawn
#

self.prompt = -> do
  pwd = Dir.pwd.sub Regexp.new(ENV['HOME']), '~'

  git_current_branch = `git cbranch 2>/dev/null`.chomp
  if git_current_branch.length > 0
    git_current_branch += " "
    git_dirty_not_cached = `git diff --shortstat`.length > 0
    git_dirty_cached = `git diff --shortstat --cached`.length > 0

    if git_dirty_not_cached || git_dirty_cached
      git_branch = intense_cyan(git_current_branch)
    else
      git_branch = cyan(git_current_branch)
    end
  else
    git_branch = ""
  end

  arrow = '➜'

  # ~/source/playground/yap master ➜
  "#{dark(green('£'))} #{yellow(pwd)} #{git_branch}#{red(arrow)} "
end

func :howmuch do |*args|
  case args.first
  when "time"
    if history_item=CommandHistory.last_run_command
      puts history_item.total_time_s
    else
      puts "Can't report on something you haven't done."
    end
  else
    puts "How much what?"
  end
end

class CommandHistoryImplementation
  def initialize
    @history = []
  end

  def push(item)
    @history.push item
  end

  def last
    @history.last
  end

  def last_run_command
    @history.reverse.detect{ |item| item.finished? }
  end

  class Item
    def initialize(command_str:command_str, started_at:Time.now)
      @command_str = command_str
      @started_at = started_at
      @ended_at = nil
    end

    def finished!
      @ended_at = Time.now
    end

    def finished?
      !!@ended_at
    end

    def total_time_s
      humanize(@ended_at - @started_at) if @ended_at && @started_at
    end

    private

    def humanize secs
      [[60, :seconds], [60, :minutes], [24, :hours], [1000, :days]].inject([]){ |s, (count, name)|
        if secs > 0
          secs, n = secs.divmod(count)
          s.unshift "#{n} #{name}"
        end
        s
      }.join(' ')
    end
  end

end

CommandHistory = CommandHistoryImplementation.new

Yap::ExecutionContext.on(:before_group_execute) do |context, commands:|
  # puts "Before group: #{context.to_s}, commands: #{commands.to_s}"
end

Yap::ExecutionContext.on(:after_group_execute) do |context, commands:|
  # puts "After group: #{context.to_s}, commands: #{commands.to_s}"
end

Yap::ExecutionContext.on(:after_process_finished) do |context, *args|
  # puts "After process: #{context.to_s}, args: #{args.inspect}"
end


Yap::ExecutionContext.on(:before_execute) do |context, command:|
  CommandHistory.push CommandHistoryImplementation::Item.new(command_str: command.str, started_at: Time.now)
end

Yap::ExecutionContext.on(:after_execute) do |context, command:, result:|
  CommandHistory.last.finished!
  # if result.status_code == 0
  #   # t = TermInfo.new("xterm-color", STDOUT)
  #   # h, w = t.screen_size
  #   # t.control "cub", w
  #   # # msg =
  #   # t.control "cuf"
  #   # # t.control "home"
  #   #
  #   # # t.write "hi"
  #   # # t.control "rc"
  # end
end
