#!/usr/bin/ruby

# ENV["PATH"] = "/Applications/Postgres.app/Contents/MacOS/bin:/usr/local/share/npm/bin/:/usr/local/heroku/bin:/Users/zdennis/.bin:/Users/zdennis/.rvm/gems/ruby-2.1.5/bin:/Users/zdennis/.rvm/gems/ruby-2.1.5@global/bin:/Users/zdennis/.rvm/rubies/ruby-2.1.5/bin:/usr/local/bin:/usr/local/sbin:/Users/zdennis/bin:/bin:/opt/local/bin:/opt/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/X11/bin:/usr/local/CrossPack-AVR/bin:/private/tmp/.tidbits/bin:/Users/zdennis/source/playground/AdobeAir/AdobeAIRSDK/bin:/Users/zdennis/.rvm/bin:/Users/zdennis/Downloads/adt-bundle-mac-x86_64-20130219/sdk/tools/:/Users/zdennis/.rvm/bin"
# ENV["GEM_HOME"] = "/Users/zdennis/.rvm/gems/ruby-2.1.5:/Users/zdennis/.rvm/gems/ruby-2.1.5@global"

require 'chronic'
require 'term/ansicolor'
require 'terminfo'

env.delete("BUNDLE_GEMFILE")
# env.delete("BUNDLE_BIN_PATH")

func :reload! do |args:, stdin:, stdout:, stderr:|
  stdout.puts "Reloading shell:"
  stdout.print "  Saving history "
  world.addons[:history].save
  stdout.puts Term::ANSIColor.green("done")
  exec File.expand_path($0)
end

completion_cache = {}

# tab_completion_display do |matches|
#
# end

tab_completion :rake, /^(rake|be rake)\s+(.*)/ do |input_fragment, match_data|
  # |config|
  # config.completions do |input_fragment, match_data|
  results = completion_cache[Dir.pwd] ||= `bundle exec rake -T`.gsub(/^rake\s*/, '').split(/\n/)

  task_rgx = /^#{Regexp.escape(input_fragment.word[:text])}/
  results.grep(task_rgx).map do |text|
    {
      type: :rake,
      text: text.gsub(/\s*#.*$/, ''),
      descriptive_text: Term::ANSIColor.yellow(text)
    }
    # end
  end
end

#
# Configuring your prompt. This can be set to a static value or to a
# Proc like object that responds to #call. If it responds to call it will
# be used every time the prompt is to be re-drawn
#
last_prompt = nil
self.prompt = -> do
  pwd = Dir.pwd.sub Regexp.new(ENV['HOME']), '~'

  git_current_branch = `git branch 2>/dev/null | sed -n '/\* /s///p'`.chomp
  if git_current_branch.length > 0
    git_current_branch += " "
    git_dirty_not_cached = `git diff --shortstat 2>/dev/null`.length > 0
    git_dirty_cached = `git diff --shortstat --cached 2>/dev/null`.length > 0

    if git_dirty_not_cached || git_dirty_cached
      git_branch = intense_cyan(git_current_branch)
    else
      git_branch = cyan(git_current_branch)
    end
  else
    git_branch = ""
  end

  arrow = '➜'

  # ~/source/playground/yap master ➜
  last_prompt = "#{dark(green('£'))} #{yellow(pwd)} #{git_branch}#{red(arrow)} "
end


###############################################################################
#                          USER-DEFINED FUNCTIONS
#------------------------------------------------------------------------------
# User-defined functions can be accessed in the shell like any command. They
# take precedence over programs found on the file-system, but they do not
# take precedent over user-defined aliases.
#
# For example, take `upcase` below:
#
#    func :upcase do |stdin:, stdout:|
#      str = stdin.read
#      stdout.puts str.upcase
#    end
#
# You can issue "upcase" in the shell where-ever you'd expect to place the name
# of a command.
#
# == Function Parameters
#
# User-defined functions can receive the following arguments:
#
#  * command: the name of the command the user-entered
#  * args: the list of arguments supplied to the command
#  * stdin: the way to access stdin (e.g. DO NOT CALL STDIN or $stdin)
#  * stdout: the way to access stdout (e.g. DO NOT CALL STDOUT or $stdout)
#  * stderr: the way to access stderr (e.g. DO NOT CALL STDERR or $stderr)
#  * world: the Shell's currently known world
#
# These arguments are all optional. You only need to specify what your
# function is going to use.
#
# Following, are a number of examples showcasing their power and flexibility.
###############################################################################

# upcase is reads from stdin and upcases every letter.
#
# Example:
#   yap> echo "hi there" | upcase
#   HI THERE
func :upcase do |stdin:, stdout:|
  str = stdin.read
  stdout.puts str.upcase
end

# This shell function uses a  Regexp to match on a command of 2 or more dots.
# It's for traversing up N directories. Two dots ("..") is the minimum and
# is used to go to the parent. Every dot after that goes up one more directory
# level.
#
# Example:
#   ~/foo/bar/baz> ..
#   ~/foo/bar> ...
#   ~/
func /^\.{2,}$/ do |command:|
  (command.length - 1).times { Dir.chdir("..") }
end

func /^\+(.*)/ do |command:, args:|
  puts command
  puts args.inspect
end

func /^\d+.times\s*/ do |line:|
  line =~ /^(\d+).times(?:\s+as\s+([A-z0-9]+))?\s*:\s*(.*)$/
  num = $1.to_i
  as_counter = $2
  statement = $3

  last_result = nil
  (1..num).each do |n|
    if as_counter
      statement2 = statement.gsub("$#{as_counter}", n.to_s)
      last_result = shell statement2, last_result: last_result
    else
      last_result = shell statement, last_result: last_result
    end
  end

  last_result
end

func /^(\d+\.\.\d+)/ do |line:|
  line =~ /^(\d+)\.\.(\d+)(?:\s+as\s+([A-z0-9]+))?\s*:\s*(.*)$/
  start, stop = $1.to_i, $2.to_i
  as_counter = $3
  statement = $4

  last_result = nil
  (start..stop).each do |n|
    if as_counter
      statement2 = statement.gsub("$#{as_counter}", n.to_s)
      last_result = shell statement2, last_result: last_result
    else
      last_result = shell statement, last_result: last_result
    end
  end

  last_result
end

# This shell function uses a custom object that responds to the #match(...)
# method. This is nothing more than an basic "history" implementation.
#
history_matcher = Object.new
def history_matcher.match(command)
  command == ".h"
end

# Allows for a single numeric argument which will be used to determine
# how many history items to show (not including this command). If no argument
# if provided then it will show the entire shell history.
func history_matcher do |world:, args:, stdout:|
  num_commands = args.first.to_i
  num_commands = world.history.length - 1 if num_commands == 0
  world.history[-(num_commands + 1)...-1].each_with_index do |command, i|
    stdout.puts "    #{i}   #{command}"
  end
end
