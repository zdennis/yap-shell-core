#!/usr/bin/ruby

# ENV["PATH"] = "/Applications/Postgres.app/Contents/MacOS/bin:/usr/local/share/npm/bin/:/usr/local/heroku/bin:/Users/zdennis/.bin:/Users/zdennis/.rvm/gems/ruby-2.1.5/bin:/Users/zdennis/.rvm/gems/ruby-2.1.5@global/bin:/Users/zdennis/.rvm/rubies/ruby-2.1.5/bin:/usr/local/bin:/usr/local/sbin:/Users/zdennis/bin:/bin:/opt/local/bin:/opt/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/X11/bin:/usr/local/CrossPack-AVR/bin:/private/tmp/.tidbits/bin:/Users/zdennis/source/playground/AdobeAir/AdobeAIRSDK/bin:/Users/zdennis/.rvm/bin:/Users/zdennis/Downloads/adt-bundle-mac-x86_64-20130219/sdk/tools/:/Users/zdennis/.rvm/bin"
# ENV["GEM_HOME"] = "/Users/zdennis/.rvm/gems/ruby-2.1.5:/Users/zdennis/.rvm/gems/ruby-2.1.5@global"

require 'chronic'
require 'term/ansicolor'
require 'terminfo'

env.delete("BUNDLE_GEMFILE")
env.delete("BUNDLE_BIN_PATH")


Yap::Shell::Execution::Context.on(:after_execute) do |world, command:, **kwargs|
  if Dir.pwd =~ /tahi/
    env["PATH"] = "/Users/zdennis/.rvm/gems/ruby-2.2.2@tahi/bin:/Users/zdennis/.rvm/gems/ruby-2.2.2@global/bin:/Users/zdennis/.rvm/rubies/ruby-2.2.2/bin:/Users/zdennis/.rvm/bin:/Applications/Postgres.app/Contents/MacOS/bin:/usr/local/share/npm/bin:/usr/local/heroku/bin:/Users/zdennis/.bin:/usr/local/bin:/usr/local/sbin:/Users/zdennis/bin:/bin:/opt/local/bin:/opt/local/sbin:/usr/bin:/usr/sbin:/sbin:/opt/X11/bin:/usr/local/CrossPack-AVR/bin:/Users/zdennis/source/mhs_projects/tahi/.tidbits/bin:/Users/zdennis/source/playground/AdobeAir/AdobeAIRSDK/bin:/Users/zdennis/Downloads/adt-bundle-mac-x86_64-20130219/sdk/tools/"
    env["GEM_HOME"] = "/Users/zdennis/.rvm/gems/ruby-2.2.2@tahi"
    env["GEM_PATH"] = "/Users/zdennis/.rvm/gems/ruby-2.2.2@tahi:/Users/zdennis/.rvm/gems/ruby-2.2.2@global"
  end
end

completion_cache = {}

# tab_completion_display do |matches|
#
# end

tab_completion :rake, /^(rake|be rake)\s+(.*)/ do |input_fragment, match_data|
  # |config|
  # config.completions do |input_fragment, match_data|
    results = completion_cache[Dir.pwd] ||= `bundle exec rake -T`.gsub(/^rake\s*/, '').split(/\n/)

    task_rgx = /^#{Regexp.escape(input_fragment.word[:text])}/
    results.grep(task_rgx).map do |text|
      OpenStruct.new(
        type: :rake,
        text: text.gsub(/\s*#.*$/, ''),
        descriptive_text: Term::ANSIColor.yellow(text)
      )
    # end
  end
end

#
# Configuring your prompt. This can be set to a static value or to a
# Proc like object that responds to #call. If it responds to call it will
# be used every time the prompt is to be re-drawn
#
last_prompt = nil
self.prompt = -> do
  pwd = Dir.pwd.sub Regexp.new(ENV['HOME']), '~'

  git_current_branch = `git branch 2>/dev/null | sed -n '/\* /s///p'`.chomp
  if git_current_branch.length > 0
    git_current_branch += " "
    git_dirty_not_cached = `git diff --shortstat 2>/dev/null`.length > 0
    git_dirty_cached = `git diff --shortstat --cached 2>/dev/null`.length > 0

    if git_dirty_not_cached || git_dirty_cached
      git_branch = intense_cyan(git_current_branch)
    else
      git_branch = cyan(git_current_branch)
    end
  else
    git_branch = ""
  end

  arrow = '➜'

  # ~/source/playground/yap master ➜
  last_prompt = "#{dark(green('£'))} #{yellow(pwd)} #{git_branch}#{red(arrow)} "
end

func :upcase do |args:, stdin:, stdout:, stderr:|
  str = stdin.read
  stdout.puts str.upcase
end
